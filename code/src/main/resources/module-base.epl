module base;

// --------------------------------------- MARKET DATA RETRIEVAL -------------------------------------

@Name('RETRIEVE_MINUTE_TICKS')
@Subscriber(className='com.algoTrader.service.MarketDataServiceImpl$RetrieveTickSubscriber')
@RunTimeOnly
select
    security.id
from
    pattern[every timer:at (*, 7:22, *, *, 1:5)],
    method:LookupUtil.getSecuritiesOnWatchlistByPeriodicity('MINUTE') as security
where
    simulation = false;

@Name('RETRIEVE_HOUR_TICKS')
@Subscriber(className='com.algoTrader.service.MarketDataServiceImpl$RetrieveTickSubscriber')
@RunTimeOnly
select
    security.id
from
    pattern[every timer:at (0, 7:22, *, *, 1:5)],
    method:LookupUtil.getSecuritiesOnWatchlistByPeriodicity('HOUR') as security
where
    simulation = false;

@Name('GET_LAST_TICK')
@Priority(3)
select
    tick.security.id as securityId, tick.* as tick
from
    Tick.std:groupwin(security.id).win:time(7 days).win:length(1) as tick;

@Name('PROPAGATE_MARKET_DATA_EVENTS')
@Priority(1)
@Subscriber(className='com.algoTrader.service.MarketDataServiceImpl$PropagateTickSubscriber')
select
    *
from
    com.algoTrader.entity.marketData.MarketDataEvent;

// --------------------------------------- MARKET DATA SIMULATION -------------------------------------

@Name('SIMULATE_STOCK_OPTIONS')
@Condition(key='statement.simulateStockOptions')
@Priority(2)
@SimulationOnly
insert into
    Tick
select
    current_timestamp.toDate() as dateTime,
    RoundUtil.getBigDecimal(StockOptionUtil.getOptionPrice(option, indexTick.currentValueDouble, volaTick.currentValueDouble / 100)) as last,
    current_timestamp.toDate() as lastDateTime,
    0 as vol, 0 as volBid, 0 as volAsk, cast(0.0, BigDecimal) as bid, cast(0.0, BigDecimal) as ask, 0 as openIntrest, cast(0.0, BigDecimal) as settlement,
    option as security
from
    pattern [every indexTick=Tick(instanceof(security, com.algoTrader.entity.security.EquityIndex)) -> (volaTick=Tick(security.id=indexTick.security.volatility.id) and not Tick(security.id=indexTick.security.id))],
    method:LookupUtil.getStockOptionsOnWatchlist() as option
where
    option.underlaying.id = indexTick.security.id;

@Name('LOAD_STOCK_OPTIONS_TICKS_FROM_DB')
@Condition(key='statement.loadStockOptionsFromDB')
@Priority(2)
@SimulationOnly
insert into
    Tick
select
    tick.dateTime as dateTime,
    tick.last as last,
    tick.lastDateTime as lastDateTime,
    tick.vol as vol,
    tick.volBid as volBid,
    tick.volAsk as volAsk,
    case when tick.bid > 0 then tick.bid else 0.01 end as bid,
    tick.ask as ask,
    tick.openIntrest as openIntrest,
    tick.settlement as settlement,
    tick.security as security
from
    pattern [every (indexTick=Tick(instanceof(security, com.algoTrader.entity.security.EquityIndex)) -> volaTick=Tick(security.id=indexTick.security.volatility.id))],
    method:LookupUtil.getStockOptionsOnWatchlist() as option,
    method:LookupUtil.getTickByDateAndSecurity(indexTick.dateTime, option.id) as tick
where
    option.underlaying.id = indexTick.security.id;

@Name('SIMULATE_FUTURES_BY_UNDERLYING')
@Condition(key='statement.simulateFuturesByUnderlaying')
@Priority(2)
@SimulationOnly
insert into
    Tick
select
    current_timestamp.toDate() as dateTime,
    RoundUtil.getBigDecimal(FutureUtil.getFuturePrice(future, indexTick.currentValueDouble)) as last,
    current_timestamp.toDate() as lastDateTime,
    0 as vol, 0 as volBid, 0 as volAsk, cast(0.0, BigDecimal) as bid, cast(0.0, BigDecimal) as ask, 0 as openIntrest, cast(0.0, BigDecimal) as settlement,
    future as security
from
    Tick(instanceof(security, com.algoTrader.entity.security.EquityIndex)) as indexTick,
    method:LookupUtil.getFuturesOnWatchlist() as future
where
    future.underlaying.id = indexTick.security.id;

@Name('SIMULATE_FUTURES_BY_GENERIC_FUTURES')
@Condition(key='statement.simulateFuturesByGenericFutures')
@Priority(2)
@SimulationOnly
insert into
    Tick
select
    current_timestamp.toDate() as dateTime,
    genericFutureTick.last as last,
    current_timestamp.toDate() as lastDateTime,
    0 as vol, 0 as volBid, 0 as volAsk,    cast(0.0, BigDecimal) as bid, cast(0.0, BigDecimal) as ask,    0 as openIntrest, cast(0.0, BigDecimal) as settlement,
    future as security
from
    Tick(instanceof(security, com.algoTrader.entity.security.GenericFuture)) as genericFutureTick,
    method:LookupUtil.getFuturesOnWatchlist() as future
where
    future.underlaying.id = genericFutureTick.security.underlaying.id
and
    future.expiration = cast(genericFutureTick.security.expiration?, java.util.Date);

// --------------------------------------- PORTFOLIO MANAGEMENT -------------------------------------

@Name('CREATE_PORTFOLIO_VALUE')
@Subscriber(className='com.algoTrader.esper.subscriber.PrintPortfolioValueSubscriber')
insert into
    Portfolio
select
    current_timestamp() as timestamp,
    LookupUtil.getPortfolioValue() as value,
    cashTransaction
from
    pattern[
        every(timer:at (0, 10:18, *, *, 1:5)
        or cashTransaction=Transaction(
            type=TransactionType.CREDIT
            or type=TransactionType.DEBIT
            or type=TransactionType.INTREST_PAID
            or type=TransactionType.INTREST_RECEIVED
            or type=TransactionType.FEES)
        or EndOfSimulation)]
where
    LookupUtil.hasLastTicks();

@Name('SET_MARGINS')
@Listeners(classNames={'com.algoTrader.service.PositionServiceImpl$SetMarginsListener'})
@Condition(key='statement.setMargins')
select
    *
from
    pattern[every timer:at (0, 7, *, *, 1:5)];

@Name('EXPIRE_POSITION')
@Listeners(classNames={'com.algoTrader.service.PositionServiceImpl$ExpirePositionListener'})
@Condition(key='statement.expirePosition')
select
    *
from
    pattern[every timer:at (0, 13, *, *, 5)];

@Name('CLOSE_POSITION')
@Subscriber(className='com.algoTrader.service.PositionServiceImpl$ClosePositionSubscriber')
@Condition(key='statement.closePosition')
select
    position.id
from
    Tick as tick,
    method:LookupUtil.getPositions(tick.security) as position
where
    position.quantity != 0
and
    position.exitValue != null
and
    ((position.direction = Direction.SHORT and (tick.currentValue >= position.exitValue))
    or
    (position.direction = Direction.LONG and (tick.currentValue <= position.exitValue)));

@Name('PROCESS_CASH_TRANSACTIONS')
@Listeners(classNames={'com.algoTrader.service.AccountServiceImpl$ProcessCashTransactionsListener'})
@RunTimeOnly
select *
from
    pattern[every timer:at (0, 8, *, *, 1:5)]
where
    simulation = false;

@Name('REBALANCE_PORTFOLIO')
@Listeners(classNames={'com.algoTrader.service.AccountServiceImpl$RebalancePortfolioListener'})
@Condition(key='statement.rebalancePortfolio')
select
    *
from
    pattern[every timer:at (0, 18, 1, *, *) -> Portfolio];

@Name('EQUALIZE_FOREX_PORTFOLIO')
@Listeners(classNames={'com.algoTrader.service.ForexServiceImpl$EqualizeForexListener'})
@Condition(key='statement.equalizeForex')
select
    *
from
    pattern[every timer:at (0, 10, *, *, 3) -> Portfolio];

// --------------------------------------- PERFORMANCE MEASUREMENT  -------------------------------------

@Name('CREATE_MONTHLY_PERFORMANCE')
@SimulationOnly
@Priority(2)
insert into
    MonthlyPerformance
select
    current_timestamp().toDate().minus(1 month) as date,
    portfolio.value.netLiqValue / prior(1, portfolio.value.netLiqValue) - 1 as value
from
    pattern[(every timer:at (0, 0, 1, *, *) or EndOfSimulation) -> portfolio=Portfolio]
having
    prior(1, portfolio.value.netLiqValue) != null and
    portfolio.value.netLiqValue != prior(1, portfolio.value.netLiqValue);

@Name('CREATE_PERFORMANCE_KEYS')
@SimulationOnly
insert into
    PerformanceKeys
select
    perf.datapoints as n,
    perf.average as avgM,
    perf.stddev as stdM,
    Math.pow(factor.geomaverage,12) - 1  as avgY,
    perf.stddev * Math.sqrt(12) as stdY,
    (Math.pow(factor.geomaverage,12) - 1 - marketIntrest) / (perf.stddev * Math.sqrt(12)) as sharpRatio
from
    MonthlyPerformance.win:keepall().stat:uni(value) as perf,
    MonthlyPerformance.win:keepall().stat:uni(1 + value) as factor;

@Name('ALL_TRADES')
@SimulationOnly
insert into
    AllTrades
select
    count(allTrades) as count,
    sum(allTrades.profit) as totalProfit,
    avg(allTrades.profit) as avgProfit,
    avg(allTrades.profitPct) as avgProfitPct,
    avg(allTrades.avgAge) as avgAge
from
    TradePerformance.win:keepall() as allTrades;

@Name('WINNING_TRADES')
@SimulationOnly
insert into
    WinningTrades
select
    count(winningTrades) as count,
    sum(winningTrades.profit) as totalProfit,
    avg(winningTrades.profit) as avgProfit,
    avg(winningTrades.profitPct) as avgProfitPct,
    avg(winningTrades.avgAge) as avgAge
from
    TradePerformance(winning = true).win:keepall() as winningTrades;

@Name('LOOSING_TRADES')
@SimulationOnly
insert into
    LoosingTrades
select
    count(loosingTrades) as count,
    sum(loosingTrades.profit) as totalProfit,
    avg(loosingTrades.profit) as avgProfit,
    avg(loosingTrades.profitPct) as avgProfitPct,
    avg(loosingTrades.avgAge) as avgAge
from
    TradePerformance(winning = false).win:keepall() as loosingTrades;

@Name('KEEP_MONTHLY_PERFORMANCE')
@SimulationOnly
select
    *
from
    MonthlyPerformance.win:keepall();

@Name('CREATE_DRAW_DOWN')
@SimulationOnly
insert
    into DrawDown
select
    1 - portfolio.value.netLiqValue / max(portfolio.value.netLiqValue) as amount,
    case
        when portfolio.value.netLiqValue = max(portfolio.value.netLiqValue) then DrawDownUtil.resetDrawDownPeriod()
        else DrawDownUtil.increaseDrawDownPeriod(current_timestamp - prior(1, portfolio.timestamp))
    end as period
from
    Portfolio as portfolio;

@Name('CREATE_MAX_DRAW_DOWN')
@SimulationOnly
insert into
    MaxDrawDown
select
    max(drawDown.amount) as amount,
    max(drawDown.period) as period
from
    DrawDown as drawDown;
