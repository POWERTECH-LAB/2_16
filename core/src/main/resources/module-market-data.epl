/*
 * Priorities on Tick:
 * Prio 4: CURRENT_MARKET_DATA_EVENT
 * Prio 3: UPDATE_COMPONENT_WINDOW
 * Prio 2: CLOSE_POSITION
 * Prio 1: PROPAGATE_MARKET_DATA_EVENTS
 */

@Name('TICK_WINDOW')
@RunTimeOnly()
create window
    TickWindow.std:groupwin(security.id).std:lastevent()
as select
    *,
    0 as tickerId,
    true as refresh
from
    Tick;

@Name('INSERT_INTO_TICK_WINDOW')
@RunTimeOnly()
insert into
    TickWindow
select
    tickerId,
    tick.*,
    true as refresh
from
    SubscribeTickEvent;

@Name('DELETE_FROM_TICK_WINDOW')
@RunTimeOnly()
on
    UnsubscribeTickEvent as unsubscribeEvent
delete from
    TickWindow as tickWindow
where
    tickWindow.security.id = unsubscribeEvent.securityId;

@Name('INSERT_INTO_TICK')
@RunTimeOnly()
on
    TickWindow as trigger
insert into
    Tick
select
    transpose(LookupUtil.completeTick(tickWindow, current_timestamp.toDate()))
from
    TickWindow as tickWindow
where
    trigger.security.id = tickWindow.security.id
and
    tickWindow.refresh
and
    tickWindow.security.validateTick(cast(tickWindow.getFirst(),ch.algotrader.entity.marketData.Tick))
and
    DateUtil.isMarketOpen(tickWindow.security.securityFamily, current_timestamp.toDate());

@Name('CHECK_TICK_GAPS')
@Subscriber(className='ch.algotrader.service.MarketDataService.logTickGap')
@RunTimeOnly()
select
    tick.security.id
from
    pattern [every tick=Tick(not security.securityFamily.maxGap is null)
            -> (timer:interval(tick.security.securityFamily.maxGap * 60) and not Tick(security.id = tick.security.id))]
where
    DateUtil.isMarketOpen(tick.security.securityFamily, current_timestamp.toDate());

@Name('PROPAGATE_MARKET_DATA_EVENTS')
@Subscriber(className='ch.algotrader.service.MarketDataServiceImpl$PropagateMarketDataEventSubscriber')
@Priority(1)
select
    *
from
    MarketDataEvent
where
    security is not null;

@Name('PROPAGATE_GENERIC_EVENTS')
@Subscriber(className='ch.algotrader.service.MarketDataServiceImpl$PropagateGenericEventSubscriber')
@Priority(1)
select
    *
from
    ch.algotrader.vo.GenericEventVO;

@Name('PERSIST_HOUR_TICKS')
@RunTimeOnly()
@Subscriber(className='ch.algotrader.service.MarketDataServiceImpl$PersistTickSubscriber')
on pattern
    [every timer:at(0, *, *, *, *)]
select
    *
from
    TickWindow as tickWindow
where
    tickWindow.security.validateTick(cast(tickWindow.getFirst(),ch.algotrader.entity.marketData.Tick))
and
    DateUtil.isMarketOpen(tickWindow.security.securityFamily, current_timestamp.toDate())
and
    tickWindow.security.securityFamily.periodicity = TimePeriod.fromString('HOUR'); // (HOUR is a reserved keyword)

@Name('PERSIST_MINUTE_TICKS')
@RunTimeOnly()
@Subscriber(className='ch.algotrader.service.MarketDataServiceImpl$PersistTickSubscriber')
on pattern
    [every timer:at(*, *, *, *, *)]
select
    *
from
    TickWindow as tickWindow
where
    tickWindow.security.validateTick(cast(tickWindow.getFirst(),ch.algotrader.entity.marketData.Tick))
and
    DateUtil.isMarketOpen(tickWindow.security.securityFamily, current_timestamp.toDate())
and
    tickWindow.security.securityFamily.periodicity = TimePeriod.fromString('MIN');
