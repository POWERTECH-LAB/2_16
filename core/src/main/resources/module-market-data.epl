/*
 * Priorities on Tick:
 * Prio 4: GET_LAST_TICK
 * Prio 3: UPDATE_COMPONENT_WINDOW
 * Prio 2: CLOSE_POSITION
 * Prio 1: PROPAGATE_MARKET_DATA_EVENTS
 */

@Name('TICK_WINDOW')
create window
    TickWindow.std:groupwin(security.id).std:lastevent()
as select
    *,
    0 as tickerId,
    true as refresh
from
    Tick;

@Name('INSERT_INTO_TICK_WINDOW')
@RunTimeOnly()
insert into
    TickWindow
select
    tickerId,
    tick.*,
    true as refresh
from
    SubscribeTickEvent;

@Name('DELETE_FROM_TICK_WINDOW')
@RunTimeOnly()
on
    UnsubscribeTickEvent as unsubscribeEvent
delete from
    TickWindow as tickWindow
where
    tickWindow.security.id = unsubscribeEvent.securityId;

@Name('UPDATE_TICK_WINDOW')
@RunTimeOnly()
on
    pattern [every timer:interval(misc_defaultRetrievalSeconds sec)]
update
    TickWindow as tickWindow
set
    tickWindow.refresh = true
where
    tickWindow.security.id not in (
        select
            security.id
        from
            Tick.win:time(misc_defaultRetrievalSeconds sec));

@Name('INSERT_INTO_TICK')
@RunTimeOnly()
on
    TickWindow as trigger
insert into
    Tick
select
    current_timestamp.toDate() as dateTime,
    tickWindow.last as last,
    tickWindow.lastDateTime as lastDateTime,
    tickWindow.vol as vol,
    tickWindow.volBid as volBid,
    tickWindow.volAsk as volAsk,
    tickWindow.bid as bid,
    tickWindow.ask as ask,
    tickWindow.openIntrest as openIntrest,
    tickWindow.settlement as settlement,
    LookupUtil.getSecurityInitialized(tickWindow.security.id) as security
from
    TickWindow as tickWindow
where
    trigger.security.id = tickWindow.security.id
and
    tickWindow.refresh
and
    tickWindow.security.validateTick(cast(tickWindow.getFirst(),com.algoTrader.entity.marketData.Tick))
and
    (simulation
or
    (current_timestamp.getDayOfWeek() >= Calendar.MONDAY
and
    current_timestamp.getDayOfWeek() <= Calendar.FRIDAY
and
    DateUtil.compareTime(tickWindow.security.securityFamily.marketOpen, current_timestamp.toDate()) <= 0
and
    DateUtil.compareTime(tickWindow.security.securityFamily.marketClose, current_timestamp.toDate()) >= 0));

@Name('PROPAGATE_MARKET_DATA_EVENTS')
@Subscriber(className='com.algoTrader.service.MarketDataServiceImpl$PropagateMarketDataEventSubscriber')
@Priority(1)
select
    *
from
    MarketDataEvent
where
    security is not null;

@Name('PROPAGATE_GENERIC_EVENTS')
@Subscriber(className='com.algoTrader.service.MarketDataServiceImpl$PropagateGenericEventSubscriber')
@Priority(1)
select
    *
from
    com.algoTrader.vo.GenericEventVO;

@Name('PERSIST_HOUR_TICKS')
@RunTimeOnly()
@Subscriber(className='com.algoTrader.service.MarketDataServiceImpl$PersistTickSubscriber')
on pattern
    [every timer:at(0, *, *, *, 1:5)]
select
    *
from
    TickWindow as tickWindow
where
    tickWindow.security.validateTick(cast(tickWindow.getFirst(),com.algoTrader.entity.marketData.Tick))
and
    DateUtil.compareTime(tickWindow.security.securityFamily.marketOpen, current_timestamp.toDate()) <= 0
and
    DateUtil.compareTime(tickWindow.security.securityFamily.marketClose, current_timestamp.toDate()) >= 0
and
    tickWindow.security.securityFamily.periodicity = Period.`HOUR`;

@Name('PERSIST_MINUTE_TICKS')
@RunTimeOnly()
@Subscriber(className='com.algoTrader.service.MarketDataServiceImpl$PersistTickSubscriber')
on pattern
    [every timer:at(*, *, *, *, 1:5)]
select
    *
from
    TickWindow as tickWindow
where
    tickWindow.security.validateTick(cast(tickWindow.getFirst(),com.algoTrader.entity.marketData.Tick))
and
    DateUtil.compareTime(tickWindow.security.securityFamily.marketOpen, current_timestamp.toDate()) <= 0
and
    DateUtil.compareTime(tickWindow.security.securityFamily.marketClose, current_timestamp.toDate()) >= 0
and
    tickWindow.security.securityFamily.periodicity = Period.`MINUTE`;
