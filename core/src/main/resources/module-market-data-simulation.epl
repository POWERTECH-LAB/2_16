@Name('CREATE_NATURAL_INDEX_TICK')
@Condition(key='statement.loadStockOptionsFromDB')
insert into
    NaturalIndexTick
select
    *
from
    Tick(instanceof(security, ch.algotrader.entity.security.NaturalIndex));

@Name('INSERT_INTO_TICK_OPTIONS_FROM_DB')
@SimulationOnly
@Condition(key='statement.loadStockOptionsFromDB')
@Priority(2)
insert into
    Tick
select
    tick.dateTime as dateTime,
    tick.last as last,
    tick.lastDateTime as lastDateTime,
    tick.vol as vol,
    tick.volBid as volBid,
    tick.volAsk as volAsk,
    case when tick.bid > 0 then tick.bid else 0.01 end as bid,
    tick.ask as ask,
    tick.openIntrest as openIntrest,
    tick.settlement as settlement,
    LookupUtil.getSecurityInitialized(tick.security.id) as security
from
    NaturalIndexTick as indexTick,
    method:LookupUtil.getSubscribedStockOptions() as stockOption,
    method:LookupUtil.getTickBySecurityAndMaxDate(indexTick.dateTime, stockOption.id) as tick
where
    stockOption.underlying.id = indexTick.security.id
order by
       tick.security.id;

@Name('INSERT_INTO_TICK_SIMULATED_OPTIONS_BY_IVOL')
@SimulationOnly
@Condition(key='statement.simulateStockOptions')
@Priority(2)
insert into
    Tick
select
    current_timestamp.toDate() as dateTime,
    RoundUtil.getBigDecimal(StockOptionUtil.getOptionPrice(option, fxTick.currentValueDouble, StockOptionUtil.getImpliedVolatilitySABR(option, fxTick.currentValueDouble, surface)), option.securityFamily.scale) as last,
    current_timestamp.toDate() as lastDateTime,
    0 as vol, 0 as volBid, 0 as volAsk, cast(0.0, BigDecimal) as bid, cast(0.0, BigDecimal) as ask, 0 as openIntrest, cast(0.0, BigDecimal) as settlement,
    LookupUtil.getSecurityInitialized(option.id) as security
from
    Tick(instanceof(security, ch.algotrader.entity.security.Forex)) as fxTick,
    method:LookupUtil.getSABRSurface(fxTick.security.id, current_timestamp.toDate()) as surface,
    method:LookupUtil.getSubscribedStockOptions() as option
order by
    option.id;

@Name('INSERT_INTO_TICK_SIMULATED_FUTURES_BY_UNDERLYING')
@SimulationOnly
@Condition(key='statement.simulateFuturesByUnderlying')
@Priority(2)
insert into
    Tick
select
    current_timestamp.toDate() as dateTime,
    RoundUtil.getBigDecimal(FutureUtil.getFuturePrice(future, indexTick.currentValueDouble)) as last,
    current_timestamp.toDate() as lastDateTime,
    0 as vol, 0 as volBid, 0 as volAsk, cast(0.0, BigDecimal) as bid, cast(0.0, BigDecimal) as ask, 0 as openIntrest, cast(0.0, BigDecimal) as settlement,
    LookupUtil.getSecurityInitialized(future.id) as security
from
    Tick(instanceof(security, ch.algotrader.entity.security.NaturalIndex)) as indexTick,
    method:LookupUtil.getSubscribedFutures() as future
where
    future.underlying.id = indexTick.security.id;

@Name('INSERT_INTO_TICK_SIMULATED_FUTURES_BY_GENERIC_FUTURES')
@SimulationOnly
@Condition(key='statement.simulateFuturesByGenericFutures')
@Priority(2)
insert into
    Tick
select
    current_timestamp.toDate() as dateTime,
    genericFutureTick.last as last,
    current_timestamp.toDate() as lastDateTime,
    0 as vol, 0 as volBid, 0 as volAsk,    cast(0.0, BigDecimal) as bid, cast(0.0, BigDecimal) as ask,    0 as openIntrest, cast(0.0, BigDecimal) as settlement,
    LookupUtil.getSecurityInitialized(future.id) as security
from
    Tick(instanceof(security, ch.algotrader.entity.security.GenericFuture)) as genericFutureTick,
    method:LookupUtil.getSubscribedFutures() as future
where
    future.underlying.id = genericFutureTick.security.underlying.id
and
    future.expiration = cast(genericFutureTick.security.expiration?, java.util.Date);

