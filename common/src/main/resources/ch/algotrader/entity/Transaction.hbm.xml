<?xml version="1.0" encoding="UTF-8"?>
<!--
     Attention: Generated code! Do not modify by hand!
     Generated by: hibernate3/hibernate.hbm.xml.vsl in andromda-hibernate-cartridge.
  -->
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
          "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">

<hibernate-mapping default-cascade="none">
    <class name="ch.algotrader.entity.TransactionImpl"
        table="`transaction`" dynamic-insert="false" dynamic-update="false">
	    <meta attribute="implements">ch.algotrader.entity.TransactionI</meta>      
	    <meta attribute="generated-class">ch.algotrader.entity.Transaction</meta>
	    <meta attribute="class-code">
<![CDATA[	    
    /**
     * The Transaction Value without Commissions. The cash flow of individual {@link TransactionType
     * TransactionTypes} is as follows:
     * <ul>
     * <li>SELL / CREDIT / INTREST_RECEIVED / DIVIDEND / REFUND: positive cash flow</li>
     * <li>BUY / EXPIRATION / DEBIT / INTREST_PAID / FEES: negative cash flow</li>
     * <li>REBALANCE / TRANSFER: depending on sign of quantity</li>
     * </ul>
     * @return java.math.BigDecimal
     */
    public abstract java.math.BigDecimal getGrossValue();

    /**
     * @see #getGrossValue
     * @return double
     */
    public abstract double getGrossValueDouble();

    /**
     * The Transaction Value incl. Commissions and Fees.The cash flow of individual {@link
     * TransactionType TransactionTypes} is as follows:
     * <ul>
     * <li>SELL / CREDIT / INTREST_RECEIVED / DIVIDEND / REFUND: positive cash flow</li>
     * <li>BUY / EXPIRATION / DEBIT / INTREST_PAID / FEES: negative cash flow</li>
     * <li>REBALANCE / TRANSFER: depending on sign of quantity</li>
     * </ul>
     * @return java.math.BigDecimal
     */
    public abstract java.math.BigDecimal getNetValue();

    /**
     * @see #getNetValue
     * @return double
     */
    public abstract double getNetValueDouble();

    /**
     * ClearingCommission plus ExecutionCommission plus Fee
     * @return java.math.BigDecimal
     */
    public abstract java.math.BigDecimal getTotalCharges();

    /**
     * @see #getTotalCharges
     * @return double
     */
    public abstract double getTotalChargesDouble();

    /**
     * The Currency Attribution of this Transaction.
     * For all Security Types except Forex, the entire transaction value (price + commission) is
     * booked in transaction currency. For Forex Attributions are:
     * <ul>
     * <li>gross transaction value is booked in transaction currency</li>
     * <li>execution commission is booked in baseCurrency (this is IB specific!)</li>
     * <li>clearing commission is booked in transaction currency</li>
     * </ul>
     * @return java.util.Collection<ch.algotrader.vo.CurrencyAmountVO>
     */
    public abstract java.util.Collection<ch.algotrader.vo.CurrencyAmountVO> getAttributions();

    /**
     * Returns {@code true} if the Transaction is either a {@code BUY}, {@code SELL}, {@code
     * EXPIRATION} or {@code TRANSFER}.
     * @return boolean
     */
    public abstract boolean isTrade();

    /**
     * Returns {@code true}, if the Transaction influences the performance calculation.
     * For BASE these are DEBIT & CREDIT and for strategies this is only REBALANCE.
     * @return boolean
     */
    public abstract boolean isPerformanceRelevant();

]]>   
	    </meta> 	    
        <meta attribute="class-description">A transaction stored in the database. Each Fill is recorded as a transaction using this entity. In addition the table transaction also stores transactions like intrest, debit, credit  fees.</meta>
        <cache usage="read-write" />
        <comment>A transaction stored in the database. Each Fill is recorded as a transaction using this entity. In addition the table transaction also stores transactions like intrest, debit, credit  fees.</comment>
        <id name="id" type="int" >
            <column name="ID" sql-type="INTEGER"/>
            <generator class="native">
                <!-- id-generator merge-point -->
            </generator>
        </id>
        <property name="dateTime">
            <meta attribute="field-description">The dateTime of the Transaction</meta>
            <column name="DATE_TIME" not-null="true" unique="false" sql-type="TIMESTAMP">
                <comment>The dateTime of the Transaction</comment>
            </column>
            <type name="java.util.Date"/>
        </property>
        <property name="settlementDate">
            <meta attribute="field-description">The dateTime this Transaction gets settled</meta>
            <column name="SETTLEMENT_DATE" not-null="false" unique="false" sql-type="DATETIME">
                <comment>The dateTime this Transaction gets settled</comment>
            </column>
            <type name="java.util.Date"/>
        </property>
        <property name="extId">
            <meta attribute="field-description">The external Transaction Id</meta>
            <column name="EXT_ID" not-null="false" unique="true" sql-type="VARCHAR(255)">
                <comment>The external Transaction Id</comment>
            </column>
            <type name="java.lang.String"/>
        </property>
        <property name="intOrderId">
            <meta attribute="field-description">The internal Order Id</meta>
            <column name="INT_ORDER_ID" not-null="false" unique="true" sql-type="VARCHAR(255)">
                <comment>The internal Order Id</comment>
            </column>
            <type name="java.lang.String"/>
        </property>
        <property name="extOrderId">
            <meta attribute="field-description">The external Order Id</meta>
            <column name="EXT_ORDER_ID" not-null="false" unique="true" sql-type="VARCHAR(255)">
                <comment>The external Order Id</comment>
            </column>
            <type name="java.lang.String"/>
        </property>
        <property name="quantity">
            <meta attribute="field-description">The quantity of the Transaction. For different {@link TransactionType TransactionTypes} quantities are as follows:
ul
liBUY: pos/li
liSELL: neg/li
liEXPIRATION: pos/neg/li
liTRANSFER : pos/neg/li
liCREDIT: 1/li
liINTREST_RECEIVED: 1/li
liREFUND : 1/li
liDIVIDEND : 1/li
liDEBIT: -1/li
liINTREST_PAID: -1/li
liFEES: -1/li
/ul</meta>
            <column name="QUANTITY" not-null="true" unique="false" sql-type="BIGINT">
                <comment>The quantity of the Transaction. For different {@link TransactionType TransactionTypes} quantities are as follows:
ul
liBUY: pos/li
liSELL: neg/li
liEXPIRATION: pos/neg/li
liTRANSFER : pos/neg/li
liCREDIT: 1/li
liINTREST_RECEIVED: 1/li
liREFUND : 1/li
liDIVIDEND : 1/li
liDEBIT: -1/li
liINTREST_PAID: -1/li
liFEES: -1/li
/ul</comment>
            </column>
            <type name="long"/>
        </property>
        <property name="price">
            <meta attribute="field-description">The price of this Transaction. Is always positive</meta>
            <column name="PRICE" not-null="true" unique="false" sql-type="Decimal(15,6)">
                <comment>The price of this Transaction. Is always positive</comment>
            </column>
            <type name="java.math.BigDecimal"/>
        </property>
        <property name="executionCommission">
            <meta attribute="field-description">The Execution Commission of this Transaction.</meta>
            <column name="EXECUTION_COMMISSION" not-null="false" unique="false" sql-type="Decimal(15,6)">
                <comment>The Execution Commission of this Transaction.</comment>
            </column>
            <type name="java.math.BigDecimal"/>
        </property>
        <property name="clearingCommission">
            <meta attribute="field-description">The Clearing Commission of this Transaction.</meta>
            <column name="CLEARING_COMMISSION" not-null="false" unique="false" sql-type="Decimal(15,6)">
                <comment>The Clearing Commission of this Transaction.</comment>
            </column>
            <type name="java.math.BigDecimal"/>
        </property>
        <property name="fee">
            <meta attribute="field-description">The Exchange Fees of this Transaction.</meta>
            <column name="FEE" not-null="false" unique="false" sql-type="Decimal(15,6)">
                <comment>The Exchange Fees of this Transaction.</comment>
            </column>
            <type name="java.math.BigDecimal"/>
        </property>
        <property name="currency">
            <meta attribute="field-description">The {@link Currency} of this Position.</meta>
            <meta attribute="property-type">ch.algotrader.enumeration.Currency</meta>
            <column name="CURRENCY" not-null="true" unique="false" sql-type="VARCHAR(255)">
                <comment>The {@link Currency} of this Position.</comment>
            </column>
            <type name="ch.algotrader.hibernate.HibernateEnumType">
                 <param name="enumClassName">ch.algotrader.enumeration.Currency</param>
            </type>
        </property>
        <property name="type">
            <meta attribute="field-description">The {@link TransactionType}</meta>
            <meta attribute="property-type">ch.algotrader.enumeration.TransactionType</meta>
            <column name="TYPE" not-null="true" unique="false" sql-type="VARCHAR(255)">
                <comment>The {@link TransactionType}</comment>
            </column>
            <type name="ch.algotrader.hibernate.HibernateEnumType">
                 <param name="enumClassName">ch.algotrader.enumeration.TransactionType</param>
            </type>
        </property>
        <property name="description">
            <meta attribute="field-description">An arbitrary Description of the Transaction</meta>
            <column name="DESCRIPTION" not-null="false" unique="false" sql-type="VARCHAR(255)">
                <comment>An arbitrary Description of the Transaction</comment>
            </column>
            <type name="java.lang.String"/>
        </property>
        <many-to-one name="account" class="ch.algotrader.entity.AccountImpl" foreign-key="TRANSACTION_ACCOUNT_FKC" not-null="false" lazy="proxy" fetch="select">
            <meta attribute="property-type">ch.algotrader.entity.Account</meta>
            <meta attribute="field-description">Represents an actual Account / AccountGroup / AllocationProfile with an external Broker / Bank</meta>
            <column name="ACCOUNT_FK" not-null="false" sql-type="INTEGER">
                <comment>Represents an actual Account / AccountGroup / AllocationProfile with an external Broker / Bank</comment>
            </column>
        </many-to-one>
        <many-to-one name="position" class="ch.algotrader.entity.PositionImpl" foreign-key="TRANSACTION_POSITION_FKC" not-null="false" lazy="proxy" fetch="select">
            <meta attribute="property-type">ch.algotrader.entity.Position</meta>
            <meta attribute="field-description">A position of a particular security owned by a particular strategy. For each opening transaction a
position is created. The position object remains in place even if a corresponding closing
transaction is carried out and the quantity of the position becomes 0.
p
Since some values (e.g. {@code marketValue}) depend on whether the position is long or short,
aggregated position values for the same security (of different strategies) cannot be retrieved just
by adding position values from the corresponding strategies.
p
Example:
ul
liSecurity: VIX Dec 2012/li
liCurrent Bid: 16.50/li
liCurrent Ask: 16.60/li
liStrategy A: quantity +10 - marketValue: 10 * 1000 * 16.50 = 165000/li
liStrategy B: quantity -10 - marketValue: 10 * 1000 * 16.60 = -166000/li
/ul
p
The sum of above marketValues would be -1000 which is obviously wrong.
p
As a consequence the {@code PortfolioDAO} provides lookup-methods that aggregate positions from the
same security (of different strategies) in the correct manner.</meta>
            <column name="POSITION_FK" not-null="false" sql-type="INTEGER">
                <comment>A position of a particular security owned by a particular strategy. For each opening transaction a
position is created. The position object remains in place even if a corresponding closing
transaction is carried out and the quantity of the position becomes 0.
p
Since some values (e.g. {@code marketValue}) depend on whether the position is long or short,
aggregated position values for the same security (of different strategies) cannot be retrieved just
by adding position values from the corresponding strategies.
p
Example:
ul
liSecurity: VIX Dec 2012/li
liCurrent Bid: 16.50/li
liCurrent Ask: 16.60/li
liStrategy A: quantity +10 - marketValue: 10 * 1000 * 16.50 = 165000/li
liStrategy B: quantity -10 - marketValue: 10 * 1000 * 16.60 = -166000/li
/ul
p
The sum of above marketValues would be -1000 which is obviously wrong.
p
As a consequence the {@code PortfolioDAO} provides lookup-methods that aggregate positions from the
same security (of different strategies) in the correct manner.</comment>
            </column>
        </many-to-one>
        <many-to-one name="security" class="ch.algotrader.entity.security.SecurityImpl" foreign-key="TRANSACTION_SECURITY_FKC" not-null="false" lazy="proxy" fetch="select">
            <meta attribute="property-type">ch.algotrader.entity.security.Security</meta>
            <meta attribute="field-description">The base class of all Securities in the system</meta>
            <column name="SECURITY_FK" not-null="false" sql-type="INTEGER">
                <comment>The base class of all Securities in the system</comment>
            </column>
        </many-to-one>
        <many-to-one name="strategy" class="ch.algotrader.entity.strategy.StrategyImpl" foreign-key="TRANSACTION_STRATEGY_FKC" not-null="true" lazy="proxy" fetch="select">
            <meta attribute="property-type">ch.algotrader.entity.strategy.Strategy</meta>
            <meta attribute="field-description">Represents a running Strategy within the system. In addition the AlgoTrader Server is also
represented by an instance of this class.</meta>
            <column name="STRATEGY_FK" not-null="true" sql-type="INTEGER">
                <comment>Represents a running Strategy within the system. In addition the AlgoTrader Server is also
represented by an instance of this class.</comment>
            </column>
        </many-to-one>
    </class>
</hibernate-mapping>
